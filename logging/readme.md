# Модуль logging для Python.
  В Python есть отличная встроенная библиотека - logging. Часто ее противопоставляют print-ам, однако на мой взгляд это гораздо более весомый инструмент. Разобравшись с некотрыми приемами в работе, хочу поделиться с сообществом наиболее, на мой взгляд, интересными вещами. Данная статья основана на [официальной](https://docs.python.org/3/library/logging.html) [документации](https://docs.python.org/3/howto/logging.html), и по сути является частичным вольным переводом.

## Когда использовать logging
Для самого простого использования, модуль предоставляет функции debug(), info(), warning(), error() и critical(). Название функций соответствует названию уровней или серьезности логируемых событий. Рекомендации по использованию стандартных уровней сведены в таблицу (в порядке возрастания серьезности).

Уровень сообщений | Когда использовать
--- | ---
DEBUG | Вывод детальной информации при поиске проблем в программе
INFO | Подтверждения, когда программа работает так ожидается
WARNING | Индикация того что произошло что-то неожиданное или указывающее на проблемы в ближайшем будущем, программа все еще работает так как ожидается
ERROR | Из-за серьезной ошибки программа не смогла выполнить какую-либо функцию
CRITICAL | Критическая ошибка, выполнение программы невозможно

Уровень логирования по умолчанию - `WARNING`, это означает что сообщения этого уровня или выше будут обработаны, ниже - отброшены.

## Simple example. (или В Бой!)
Самый простой пример использования модуля выглядит так:
```
import logging

logging.warning("Warning message")
logging.info("Info message")
```
если запустить скрипт с этим кодом, то в консоли будет выведено:
```
WARNING:root:Warning message
```
 что мы видим: `WARNING` это индикация уровня события, `root` - имя логгера, `Warning message` сообщение. Пока не обращайте внимание на имя логгера, это будет объяснено позже. Строка `logging.info("Info message")` была проигнорирована т.к. уровень `INFO` ниже уровня `WARNING` (который был установлен по умолчанию).

## Немного теории.
Модуль logging имеет модульный подход и предлагает несколько категорий компонентов: логгеры (loggers), обработчики (handlers), фильтры (filters) и объекты форматирования (formatters).
* [logger](https://docs.python.org/3/library/logging.html#logger-objects) содержит интерфейс для логирования. Это основной объект, именно он создает записи в лог.
* [handler](https://docs.python.org/3/library/logging.html#handler-objects) обработчик, который направляет созданные логгером записи в пункт назначения. Например вывод в консоль, запись в файл, отправка письма и т.д.
* [filter](https://docs.python.org/3/library/logging.html#filter-objects) позволяет получить больший контроль над фильтрацией записей чем стандартные уровни логирования.
> Базовый класс реализует только одно поведение: выстраивание иерархии логгеров при помощи имени логгера и точки. Например инициализирован логгер с именем `A.B`, тогда записи логгеров с именами `A.B.C`, `A.B.C.D`, `A.B.D` будут обработаны, а логгеров с именами `A.BB` или `B.B.C` отброшены.

* [formatter](https://docs.python.org/3/library/logging.html#formatter-objects) является шаблоном для форматирования записи.

## Способы конфигурации модуля.
### [basicConfig](https://docs.python.org/3/library/logging.html#logging.basicConfig)
Это базовый, простой способ. Рассмотрим его, на примере чтобы погрузится удивительнйый мир логирования (смайлик):
```
import logging

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    filename='example.log',
    filemode='w',
    level=logging.DEBUG,
    )
logging.debug('This message should go to the log file')
logging.info('So should this')
logging.warning('And this, too')
```
Рассмотрим параметры переданные в baseConfig: `format` - преобразует вывод логера по переданному шаблону, `filename` - сообщает логгеру что необходимо логи заносить в файл с переданным названием `example.log`, `filemod`: `w` - перезаписывать файл при каждом запуске файла, `a` - дописывать в конец файла и наконец `level` устанавливает уровень логирования `DEBUG`. В результате выполнения будет создан файл `filemod.log` в котором окажутся записи:
```
2018-05-13 23:41:47,769 - root - DEBUG - This message should go to the log file
2018-05-13 23:41:47,769 - root - INFO - So should this
2018-05-13 23:41:47,769 - root - WARNING - And this, too
```
дата и время возможно будут другими. Этот способ конфигурирования на сколько прост, настолько же не понятен и не гибок, предлагаю перейти к следующему способу.
### [getLogger](https://docs.python.org/3/library/logging.html#logger-objects)
Этот способ открывает весь набор инструментов библиотеки. Для использования необходимо создать логгер, создать и добавить обработчики, фильтры и шаблон форматирования. Да, у одного логгера может быть несколько обработчиков. И снова пример:
```
import logging

# создание логгера с именем "main" (может быть любым)
logger = logging.getLogger('main')
# установка уровня логирования
logger.setLevel(logging.DEBUG)

# создание обработчика с логированием в консоль
cons_handler = logging.StreamHandler()
# установка уровня логирования конкретно этого обработчика
cons_handler.setLevel(logging.DEBUG)

# создание обработчика с логированием в файл "2_example.log"
file_handler = logging.FileHandler("3_example.log", mode="a")
file_handler.setLevel(logging.WARNING)

# создание шаблона отображения
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# связвание обработчиков с шаблоном форматирования
cons_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)

# добавление обработчиков логгеру
logger.addHandler(cons_handler)
logger.addHandler(file_handler)

# использование логгера
logger.debug('debug message')
logger.info('info message')
logger.warn('warn message')
logger.error('error message')
logger.critical('critical message')
```
По коду должно быть все понятно из комментариев, в результате выполнения получим в консоль:
```
2018-05-15 22:40:07,974 - main - DEBUG - debug message
2018-05-15 22:40:07,974 - main - INFO - info message
2018-05-15 22:40:07,974 - main - WARNING - warn message
2018-05-15 22:40:07,975 - main - ERROR - error message
2018-05-15 22:40:07,975 - main - CRITICAL - critical message
```
и файл с именем `3_example.log` с содержимым:
```
2018-05-15 22:40:07,974 - main - WARNING - warn message
2018-05-15 22:40:07,975 - main - ERROR - error message
2018-05-15 22:40:07,975 - main - CRITICAL - critical message
```
Хочу пояснить следующие моменты:
* Первым делом получаем логгер - экземпляр класса Logger с именем `main`. Причем действует правило: одно имя - один экземпляр. Это означает что при первом вызове метода логгер создается, а при последующих передается уже созданный экземпляр логгера. На практике это означает что достаточно вызвать и настроить логгер в одном месте (модуле), выполнить этот код (импортировать модуль), во всех последующих местах вызывать настроеный логгер и... просто логировать.
* Далее получаем обработчики. Полный список с описанием [здесь](https://docs.python.org/3/library/logging.handlers.html) их много и они разные: вывод в консоль, запись в файл (возможно с ротацией логов), отправка через сокет, http, UDP, отправка письмом, чтение/запись в очередь и т.д. Далее в приимерах будут те что пользовался я сам.
* Нужно четко понимать что у логгера может быть множество обработчиков, каждый обработчик может иметь свой шаблон сообщения, уровень логирования и фильтрацию. Поэтому в консоль попали все сообщения логгера, а в файл с уровнем `WARNING` и выше.
* И наконец получаем шаблоны сообщений. Параметры для шаблонов [здесь](https://docs.python.org/3/library/logging.html?highlight=logging%20formatter#logrecord-attributes), основные параметры далее в примерах примерах.
> Оптимизация. Процесс подстановки аргументов в шаблон ленивый, и произойдет только если запись действительно будет обрабатываться, однако вычисление аргуменов для логирования может быть долгим. Для того чтобы не терять время можно воспользоваться методом `isEnabledFor` логгера, который принимает уровень логирования, проверяет будет ли производится запись и возвращает ответ в `True` или `False`. Например:
```
if logger.isEnabledFor(logging.DEBUG):
    logger.debug('Message with %s', expensive_func())
```

### [dictConfig](https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig)
Мой любимый способ. Сразу к примеру:
```
```
